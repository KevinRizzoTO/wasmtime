//! Function call emission.  For more details around the ABI and
//! calling convention, see [ABI].
use super::CodeGenContext;
use crate::{
    abi::{align_to, ABIArg, ABIResult, ABISig, ABI},
    masm::{MacroAssembler, OperandSize},
    reg::Reg,
    stack::Val,
};

/// All the information needed to emit a function call.
pub(crate) struct FnCall<'a> {
    /// The total stack space needed for the callee arguments on the
    /// stack, including any adjustments to the function's frame and
    /// aligned to to the required ABI alignment.
    total_arg_stack_space: u32,
    /// The stack space consumed by spilling registers placed as
    /// function arguments in the value stack.  This gets implicitly
    /// allocated by saving any live registers in the value stack, but
    /// we track it to make sure to reclaim that space once the
    /// function call ends.
    spill_stack_space: u32,
    /// The amount of memory in bytes consumed by the call. That is,
    /// any memory entries that will be used as params and that exist
    /// before any spills generated by saving live registers are
    /// counted as memory entries that will be consumed by the call,
    /// and thus we track this space to claim it once the function
    /// call has ended. This field is analogous to
    /// `spill_stack_space`, but it's kept separate for clarity and
    /// debugging purposes.
    memory_consumed: u32,
    /// The ABI-specific signature of the callee.
    abi_sig: &'a ABISig,
    /// The stack pointer offset prior to preparing and emitting the
    /// call. This is tracked to assert the position of the stack
    /// pointer after the call has finished.
    sp_offset_at_callsite: u32,
}

impl<'a> FnCall<'a> {
    /// Allocate and setup a new function call.
    ///
    /// The setup process, will first save all the live registers in
    /// the value stack, tracking down those spilled for the function
    /// arguments(see comment below for more details) it will also
    /// track all the memory entries consumed by the function
    /// call. Then, it will calculate any adjustments needed to ensure
    /// the alignment of the caller's frame.  It's important to note
    /// that the order of operations in the setup is important, as we
    /// want to calculate any adjustments to the caller's frame, after
    /// having saved any live registers, so that we can account for
    /// any pushes generated by register spilling.
    pub fn new<A: ABI, M: MacroAssembler>(
        abi: &A,
        callee_sig: &'a ABISig,
        context: &mut CodeGenContext,
        masm: &mut M,
    ) -> Self {
        let stack = &context.stack;
        let arg_stack_space = callee_sig.stack_bytes;
        let callee_params = &callee_sig.params;
        let sp_offset_at_callsite = masm.sp_offset();

        let (spilled_regs, memory_entries) = match callee_params.len() {
            0 => {
                let _ = context.spill_regs_and_count_memory_in(masm, ..);
                (0, 0)
            }
            _ => {
                // Here we perform a "spill" of the register entries
                // in the Wasm value stack, we also count any memory
                // entries used as function arguments.  Saving the
                // live registers is done by emitting push operations
                // for every `Reg` entry in the Wasm value stack. We
                // do this to be compliant with Winch's internal ABI,
                // in which all registers are treated as
                // caller-saved. For more details, see [ABI].
                //
                // The next few lines, partition the value stack into
                // two sections:
                // +------------------+--+--- (Stack top)
                // |                  |  |
                // |                  |  | 1. The top `n` elements, which are used for
                // |                  |  |    function arguments; for which we save any
                // |                  |  |    live registers, keeping track of the amount of registers
                // +------------------+  |    saved plus the amount of memory entries consumed by the function call;
                // |                  |  |    with this information we can later claim the space used by the function call.
                // |                  |  |
                // +------------------+--+---
                // |                  |  | 2. The rest of the items in the stack, for which
                // |                  |  |    we only save any live registers.
                // |                  |  |
                // +------------------+  |
                assert!(stack.len() >= callee_params.len());
                let partition = stack.len() - callee_params.len();
                let _ = context.spill_regs_and_count_memory_in(masm, 0..partition);
                context.spill_regs_and_count_memory_in(masm, partition..)
            }
        };

        let delta = calculate_frame_adjustment(
            masm.sp_offset(),
            abi.arg_base_offset() as u32,
            abi.call_stack_align() as u32,
        );

        let total_arg_stack_space =
            align_to(arg_stack_space + delta, abi.call_stack_align() as u32);
        Self {
            abi_sig: &callee_sig,
            total_arg_stack_space,
            spill_stack_space: spilled_regs * <A as ABI>::word_bytes(),
            memory_consumed: memory_entries * <A as ABI>::word_bytes(),
            sp_offset_at_callsite,
        }
    }

    /// Emit the function call.
    pub fn emit<M: MacroAssembler, A: ABI>(
        &self,
        masm: &mut M,
        context: &mut CodeGenContext,
        callee: u32,
    ) {
        masm.reserve_stack(self.total_arg_stack_space);
        self.assign_args(context, masm, <A as ABI>::scratch_reg());
        masm.call(callee);
        masm.free_stack(self.spill_stack_space + self.total_arg_stack_space + self.memory_consumed);
        context.drop_last(self.abi_sig.params.len());
        assert!(masm.sp_offset() == (self.sp_offset_at_callsite - self.memory_consumed));
        self.handle_result(context, masm);
    }

    fn assign_args<M: MacroAssembler>(
        &self,
        context: &mut CodeGenContext,
        masm: &mut M,
        scratch: Reg,
    ) {
        let arg_count = self.abi_sig.params.len();
        let stack = &context.stack;
        let mut stack_values = stack.peekn(arg_count);
        for arg in &self.abi_sig.params {
            let val = stack_values
                .next()
                .unwrap_or_else(|| panic!("expected stack value for function argument"));
            match &arg {
                &ABIArg::Reg { ty, reg } => {
                    context.move_val_to_reg(&val, *reg, masm, (*ty).into());
                }
                &ABIArg::Stack { ty, offset } => {
                    let addr = masm.address_at_sp(*offset);
                    let size: OperandSize = (*ty).into();
                    context.move_val_to_reg(val, scratch, masm, size);
                    masm.store(scratch.into(), addr, size);
                }
            }
        }
    }

    fn handle_result<M: MacroAssembler>(&self, context: &mut CodeGenContext, masm: &mut M) {
        let result = &self.abi_sig.result;
        if result.is_void() {
            return;
        }

        match result {
            &ABIResult::Reg { ty: _, reg } => {
                assert!(context.regalloc.gpr_available(reg));
                let result_reg = Val::reg(context.gpr(reg, masm));
                context.stack.push(result_reg);
            }
        }
    }
}

/// Calculates the delta needed to adjust a function's frame plus some
/// addend to a given alignment.
fn calculate_frame_adjustment(frame_size: u32, addend: u32, alignment: u32) -> u32 {
    let total = frame_size + addend;
    (alignment - (total % alignment)) % alignment
}
