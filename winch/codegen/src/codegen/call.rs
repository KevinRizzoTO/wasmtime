use super::CodeGenContext;
use crate::{
    abi::{align_to, ABIArg, ABIResult, ABISig, ABI},
    masm::{MacroAssembler, OperandSize},
    reg::Reg,
    stack::Val,
};

/// All the information needed to emit a function call.
pub(crate) struct FnCall<'a> {
    /// The total stack space needed for the callee arguments on the
    /// stack, including any adjustments to the function's frame and
    /// aligned to to the required ABI alignment.
    pub total_arg_stack_space: u32,
    /// The stack space consumed by spilling registers placed as
    /// function arguments in the value stack.  This gets implicitly
    /// allocated by saving any live registers in the value stack, but
    /// we track it to make sure to reclaim that space once the
    /// function call ends.
    pub spill_stack_space: u32,
    /// The ABI-specific signature of the callee.
    pub abi_sig: &'a ABISig,
    /// The stack pointer offset prior to preparing and emitting the
    /// call. This is tracked to assert the position of the stack
    /// pointer after the call has finished.
    sp_offset_at_callsite: u32,
}

impl<'a> FnCall<'a> {
    /// Allocate and setup a new function call.
    ///
    /// The setup process, will first save all the live registers in
    /// the value stack, tracking down those spilled for the function
    /// arguments.  Then, it will calculate any adjustments needed to
    /// ensure the alignment of the caller's frame.  It's important to
    /// note that the order of operations in the setup is important,
    /// as we want to calculate any adjustments to the caller's frame,
    /// after having saved any live registers, so that we can account
    /// for any pushes generated by register spilling.
    pub fn new<A: ABI, M: MacroAssembler>(
        abi: &A,
        callee_sig: &'a ABISig,
        context: &mut CodeGenContext,
        masm: &mut M,
    ) -> Self {
        let stack = &context.stack;
        let arg_stack_space = callee_sig.stack_bytes;
        let callee_params = &callee_sig.params;
        let sp_offset_at_callsite = masm.sp_offset();

        let spilled_regs = match callee_params.len() {
            0 => {
                let _ = context.spill_regs_in(masm, ..);
                0
            }
            _ => {
                assert!(stack.len() >= callee_params.len());
                let partition = stack.len() - callee_params.len();
                let _ = context.spill_regs_in(masm, 0..partition);
                context.spill_regs_in(masm, partition..)
            }
        };

        let delta = calculate_frame_adjustment(
            masm.sp_offset(),
            abi.arg_base_offset() as u32,
            abi.call_stack_align() as u32,
        );

        let total_arg_stack_space =
            align_to(arg_stack_space + delta, abi.call_stack_align() as u32);
        Self {
            abi_sig: &callee_sig,
            total_arg_stack_space,
            spill_stack_space: spilled_regs * <A as ABI>::word_bytes(),
            sp_offset_at_callsite,
        }
    }

    /// Emit the function call.
    pub fn emit<M: MacroAssembler, A: ABI>(
        &self,
        masm: &mut M,
        context: &mut CodeGenContext,
        callee: u32,
    ) {
        masm.reserve_stack(self.total_arg_stack_space);
        self.assign_args(context, masm, <A as ABI>::scratch_reg());
        masm.call(callee);
        masm.free_stack(self.spill_stack_space + self.total_arg_stack_space);
        context.drop_last(self.abi_sig.params.len());
        assert!(masm.sp_offset() == self.sp_offset_at_callsite);
        self.handle_result(context, masm);
    }

    fn assign_args<M: MacroAssembler>(
        &self,
        context: &mut CodeGenContext,
        masm: &mut M,
        scratch: Reg,
    ) {
        let arg_count = self.abi_sig.params.len();
        let stack = &context.stack;
        let mut stack_values = stack.peekn(arg_count);
        for arg in &self.abi_sig.params {
            let val = stack_values
                .next()
                .unwrap_or_else(|| panic!("expected stack value for function argument"));
            match &arg {
                &ABIArg::Reg { ty, reg } => {
                    context.move_val_to_reg(&val, *reg, masm, (*ty).into());
                }
                &ABIArg::Stack { ty, offset } => {
                    let addr = masm.address_from_sp(*offset);
                    let size: OperandSize = (*ty).into();
                    context.move_val_to_reg(val, scratch, masm, size);
                    masm.store(scratch.into(), addr, size);
                }
            }
        }
    }

    fn handle_result<M: MacroAssembler>(&self, context: &mut CodeGenContext, masm: &mut M) {
        let result = &self.abi_sig.result;
        if result.is_void() {
            return;
        }

        match result {
            &ABIResult::Reg { ty: _, reg } => {
                assert!(context.regalloc.gpr_available(reg));
                let result_reg = Val::reg(context.gpr(reg, masm));
                context.stack.push(result_reg);
            }
        }
    }
}

/// Calculates the delta needed to adjust a function's frame plus some
/// addend to a given alignment.
fn calculate_frame_adjustment(frame_size: u32, addend: u32, alignment: u32) -> u32 {
    let total = frame_size + addend;
    (alignment - (total % alignment)) % alignment
}
